import sys

MAX = 30
tati = [0]
tati[0] = -1
fii = [0] * MAX
sol = [0] * MAX
OPERATORI = ['-', '^', '~', '=', '!']

# = este => implica
# ! este not
# ~ este or
# - este <=>
# ^ este and

expresie = '(((P~Q)=(!(P~Q)))^(P~(!(!Q))))'
# ex: (((P~Q)=(!(P~Q)))^(P~(!(!Q)))) corect

ind = 0

# daca nu inchid toate parantezele deschise
if expresie.count('(') != expresie.count(')'):
    print('Expresia este INCORECTA')
    sys.exit()
# daca am mai multe perechi de paranteze decat conectori logici
nr_conectori = 0
for i in OPERATORI:
    nr_conectori += expresie.count(i)

if ((expresie.count('(') + expresie.count(')')) // 2 != nr_conectori):
    print('Expresia este INCORECTA')
    sys.exit()


def sift(ind, tati):
    """
    sift(ind, tati) --> This functions takes us to the father of the current node in the solution tree
    So it moves the pointer upwards

    ind --> This variable is the pointer in the solution tree
    tati --> This variable is a list that remembers the fathers of each and every node

    The function returns the pointer to the father of the curretn node, or it may return -2
    which actually means that the program will terminate at some point
    """

    if ind >= 0:
        return tati[ind]
    else:
        # sau as putea sa omor programul direct
        return -2


def percolate(ind, fii):
    """
    percolate(ind, fii) --> This function takes us one free son of the current node.
    So it moves the pointer downwards
    If I try to do something not allowed the program will terminate

    ind --> This variable is the pointer in the solution tree
    fii --> This variable is a list that remembers the sons of each and every node

    The function returns the pointer to the free son of the current node.
    """

    try:
        if sol[fii[ind][0]] == 0:
            return fii[ind][0]
        else:
            return fii[ind][1]
    except:
        print('Expresia este INCORECTA')
        sys.exit()


def create_nodes2(tati, fii, ind):
    """
    create_nodes2(tati, fii, ind) --> This function creates two new nodes in the tree.

    tati --> This variable is a list that remembers the fathers of each and every node
    fii --> This variable is a list that remembers the sons of each and every node
    ind --> This variable is the pointer in the solution tree

    The function returns the new pointer that actually points to one of the newly created sons.
    """
    fii[ind] = list()
    tati.append(ind)
    fii[ind].append(len(tati) - 1)
    tati.append(ind)
    fii[ind].append(len(tati) - 1)
    ind = len(tati) - 2
    return ind


def create_nodes1(tati, fii, ind):
    """
    create_nodes1(tati, fii, ind) --> This function creates one new node in the tree.

    tati --> This variable is a list that remembers the fathers of each and every node
    fii --> This variable is a list that remembers the sons of each and every node
    ind --> This variable is the pointer in the solution tree

    The function returns the new pointer that actually points NOT to the newly created son, but
    to the same node as the input one, because I am looking for a negation: "not"
    """

    fii[ind] = list()
    tati.append(ind)
    fii[ind].append(len(tati) - 1)

    return ind


if expresie.count('(') == 0:
    # daca nu are paranteze deschise
    print('Expresia este INCORECTA')
    sys.exit()

for i, chr in enumerate(expresie):
    # for debugging
    print(i, tati, fii, ind, sol)
    # doar daca mai am unde sa merg in fata
    if i < len(expresie) - 1:
        next_chr = expresie[i + 1]
    else:
        next_chr = ''
    if chr == ')':
        ind = sift(ind, tati)
    elif chr == '(':
        # peeking over the next item
        if next_chr == '(':
            # daca vrea sa fie complexa am nevoie de doua noduri
            ind = create_nodes2(tati, fii, ind)
        elif next_chr == '!':
            # daca e negatie am nevoie doar de un nod
            ind = create_nodes1(tati, fii, ind)
        elif next_chr.isalpha():
            # daca e litera tot am nevoie de doua noduri, dar acum
            # pot sa si pun litera unde ii este locul
            ind = create_nodes2(tati, fii, ind)
            sol[ind] = next_chr
    elif chr.isalpha():
        # daca este litera o pun si merg in sus
        sol[ind] = chr
        ind = sift(ind, tati)
    elif chr in OPERATORI:
        # daca e operrator il pun si merg in jos
        sol[ind] = chr
        ind = percolate(ind, fii)
# daca am ajuns la tatal radacinii si nu am omorat programul in prealabil
# atunci e corecta
if ind == -1:
    print('Expresia este CORECTA')
else:
    print('Expresia este INCORECTA')

# just here to check the documentation
# print(sift.__doc__)
